# 07 | 远程服务调用（上）：从本地方法到远程方法的桥梁



#### 远程服务调用（Remote Procedure Call，RPC）

~~~
1、构建分布式系统的最基本的前置条件

~~~

**RPC 本身可以解决什么问题、如何解决这些问题、为什么要这样解决**

#### **进程间通讯**

~~~java
// 调用者（Caller） ： main()
// 被调用者（Callee） ： println()
// 调用点（Call Site） ： 发生方法调用的指令流位置
// 调用参数（Parameter） ： 由Caller传递给Callee的数据，即“hello world”
// 返回值（Retval） ： 由Callee传递给Caller的数据，如果方法正常完成，返回值是void，否则是对应的异常
public static void main(String[] args) { 
  System.out.println(“hello world”);
}
~~~

~~~
通过这段伪代码，你可以发现，在完全不考虑编译器优化的前提下，程序运行至调用 println() 这一行的时候，计算机（物理机或者虚拟机）会做以下这些事情：
	1、传递方法参数：将字符串 hello world 的引用压栈。
	2、确定方法版本：根据 println() 方法的签名，确定它的执行版本其实并不是一个简单的过程，不管是编译时的静态解析也好，还是运行时的动态分派也好，程序都必须根据某些语言规范中明确定义的原则，找到明确的被调用者 Callee。这里的“明确”是指唯一的一个 Callee，或者有严格优先级的多个 Callee，比如不同的重载版本。我曾在《深入理解 Java 虚拟机》中用一整章介绍过这个过程。如果你感兴趣的话，可以去深入了解一下。
	3、执行被调方法：从栈中获得 Parameter，以此为输入，执行 Callee 内部的逻辑。
	4、返回执行结果：将 Callee 的执行结果压栈，并将指令流恢复到 Call Site 处，继续向下执行。
~~~



~~~
接下来，我们就需要考虑一下，当 println() 方法不在当前进程的内存地址空间中，会出现什么问题。不难想到，此时至少面临两个直接的障碍：
	第一个障碍，前面的第一步和第四步所做的传递参数、传回结果都依赖于栈内存的帮助，如果 Caller 与 Callee 分属不同的进程，就不会拥有相同的栈内存，那么在 Caller 进程的内存中将参数压栈，对于 Callee 进程的执行毫无意义。
	第二个障碍，第二步的方法版本选择依赖于语言规则的定义，而如果 Caller 与 Callee 不是同一种语言实现的程序，方法版本选择就将是一项模糊的不可知行为。
~~~



#### 要解决的问题

1、**两个进程之间如何交换数据的问题**

~~~
第一，管道（Pipe）或具名管道（Named Pipe） 
	ps -ef | grep java
第二，信号（Signal）
	kill
第三，信号量（Semaphore）
	信号量是用于两个进程之间同步协作的手段，相当于操作系统提供的一个特殊变量。我们可以在信号量上，进行 wait() 和 notify() 操作。
第四，消息队列（Message Queue）
	前面所说的这三种方式，只适合传递少量信息，而 POSIX 标准中，有定义“消息队列”用于进程间通讯的方法。也就是说，进程可以向队列中添加消		息，而被赋予读权限的进程则可以从队列中消费消息。消息队列就克服了信号承载信息量少、管道只能用于无格式字节流，以及缓冲区大小受限等缺点 	，但实时性相对受限。
第五，共享内存（Shared Memory）
	允许多个进程可以访问同一块内存空间，这是**效率最高**的进程间通讯形式。进程的内存地址空间是独立隔离的，但操作系统提供了让进程主动创建、映射、分离、控制某一块内存的接口。由于内存是多进程共享的，所以往往会与其它通信机制，如信号量等结合使用，来达到进程间的同步及互斥。
第六，本地套接字接口（IPC Socket）
	消息队列和共享内存这两种方式，只适合单机多进程间的通讯。而套接字接口，是更为普适的进程间通信机制，可用于不同机器之间的进程通信。
	套接字（Socket）起初是由 Unix 系统的 BSD 分支开发出来的，但现在已经移植到所有的 Unix 和 Linux 系统上了。基于效率考虑，当仅限于本机进程间通讯的时候，套接字接口是被优化过的，不会经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等操作，只是简单地将应用层数据从一个进程拷贝到另一个进程，这种进程间通讯方式有个专有的名称：Unix Domain Socket，又叫做 IPC Socket。
	
	IPC的问题：
		网络是可靠的（The network is reliable）
		延迟是不存在的（Latency is zero ）
		带宽是无限的（Bandwidth is infinite）
		网络是安全的（The network is secure）
		拓扑结构是一成不变的（Topology doesn't change）
		总会有一个管理员（There is one administrator）
		不考虑传输成本（Transport cost is zero）
		网络是同质化的（The network is homogeneous）
~~~



#### 2、跨语言怎么解决

~~~
第二个障碍，第二步的方法版本选择依赖于语言规则的定义，而如果 Caller 与 Callee 不是同一种语言实现的程序，方法版本选择就将是一项模糊的不可知行为。
~~~



~~~
RPC 是一种语言级别的通讯协议，它允许运行于一台计算机上的程序以某种管道作为通讯媒介（即某种传输协议的网络），去调用另外一个地址空间（通常为网络上的另外一台计算机）。
~~~

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210430135309388.png" alt="image-20210430135309388" style="zoom:50%;" />



#### FAQ:

老师对于IPC socket的讲解解答了我很长时间以来对本地使用RPC况下效率问题的疑惑。

一直以来都是在golang语言下使用gRPC。包括在本地process交互的情况下也会使用gRPC做IPC. 我感觉gRPC的设计理念就是面向简单，尽可能的把RPC包装成本地调用的形式。

我还想确认的一个问题是，在IPC场景下，gRPC如果不会经过打包，解包等过程，与共享内存，消息队列等IPC方式比起来会有显著的效率差异吗？差异的原因主要是哪些？

~~~
这里列的IPC方式，最快的显然是共享内存了。

IPC Socket虽然不用经过网络栈，但是还有另一个重要开销是socket接口实现在OS的内核空间中的，用户进程要使用它，就无可避免地在收和发会涉及到从用户空间向内核空间复制数据，以及反过来的两次复制过程。如果用共享内存就不会涉及到这方面问题，完全的zero-copy。
现在一些对通讯性能敏感的场景，譬如sidecar与服务的通讯，都会将ipc socket改造为share memory作为一种可考虑的方式。
~~~

